//-------缓存控制---------
这个挺好的：href="src/css/app.css?v=20170921"
用localStorage做资源缓存-->>就算了吧。


//---------性能优化-----------

‘重绘’和‘重排’是导致网页性能低下的根本原因。
1、‘重绘’不一定导致‘重排’，比如，改变单元格的颜色
2、‘重排’必然导致‘重绘’，比如改变位置。
3、table元素的重排和重绘成本，要高于div元素

一般来说：
样式的写操作之后，如果有下面这些属性的读操作，
都会引发浏览器立即重新渲染。
1、offsetTop/offsetLeft/offsetWidth/offsetHeight
2、scrollTop/scrollLeft/scrollWidth/scrollHeight
3、clientTop/clientLeft/clientWidth/clientHeight
4、getComputedStyle()

// bad
div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

// good
var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + "px";
div.style.top = top + 10 + "px";

提高性能的九个技巧
1、多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
2、如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。？？？
3、不要一条条地改变样式，而要通过改变class
4、尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。
比如，操作Document Fragment对象，完成后再把这个对象加入DOM。
再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。
5、先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。
这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。
6、position属性为absolute或fixed的元素，重排的开销会比较小，
因为不用考虑它对其他元素的影响。


//关于ie8 的兼容
1、<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    如果安装了GCF，则使用GCF来渲染页面，如果没安装GCF，则使用最高版本的IE内核进行渲染。
    Google Chrome Frame（谷歌内嵌浏览器框架GCF）。
    可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，
而且支持IE6、7、8等多个版本的IE浏览器。
2、css3:border-raduis,opacity
2、js:获取样式，e,e.target,Indexof(),trim(),
2、html:placeholder  jquery.placeholder.js
3、终结者->>好像这个js获取不到的样子
<!–[if lt IE 9]>
  <script src=”http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js”></script>
  <![endif]–>


//默认新窗口打开链接
<base target="_blank" />


