//-------缓存控制---------
这个挺好的：href="src/css/app.css?v=20170921"
用localStorage做资源缓存-->>就算了吧。


//---------性能优化-----------

‘重绘’和‘重排’是导致网页性能低下的根本原因。
1、‘重绘’不一定导致‘重排’，比如，改变单元格的颜色
2、‘重排’必然导致‘重绘’，比如改变位置。
3、table元素的重排和重绘成本，要高于div元素

一般来说：
样式的写操作之后，如果有下面这些属性的读操作，
都会引发浏览器立即重新渲染。
1、offsetTop/offsetLeft/offsetWidth/offsetHeight
2、scrollTop/scrollLeft/scrollWidth/scrollHeight
3、clientTop/clientLeft/clientWidth/clientHeight
4、getComputedStyle()

// bad
div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

// good
var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + "px";
div.style.top = top + 10 + "px";

提高性能的九个技巧
1、多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
2、如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。？？？
3、不要一条条地改变样式，而要通过改变class
4、尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。
比如，操作Document Fragment对象，完成后再把这个对象加入DOM。
再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。
5、先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。
这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。
6、position属性为absolute或fixed的元素，重排的开销会比较小，
因为不用考虑它对其他元素的影响。




function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  element.style.height = (currentHeight * 2) + 'px';
}
elements.forEach(doubleHeight);
上面的代码使用循环操作，将每个元素的高度都增加一倍。
可是，每次循环都是，读操作后面跟着一个写操作。
这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。



function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  window.requestAnimationFrame(function () {
    element.style.height = (currentHeight * 2) + 'px';
  });
}
elements.forEach(doubleHeight);
可以使用window.requestAnimationFrame()，让读操作和写操作分离，
把所有的写操作放到下一次重新渲染。



$(window).on('scroll', function() {
   window.requestAnimationFrame(scrollHandler);
});
页面滚动事件（scroll）的监听函数，
就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染




//=====有意思==
var rAF = window.requestAnimationFrame;
var degrees = 0;
function update() {
  //读取
  div.style.transform = "rotate(" + degrees + "deg)";
  //console.log('updated to degrees ' + degrees);
  //改变
  degrees = degrees + 1;
  //推迟
  rAF(update);
}
rAF(update);
当然，最适用的场合还是网页动画。上面是一个旋转动画的例子，元素每一帧旋转1度。


//关于ie8 的兼容
1、<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    如果安装了GCF，则使用GCF来渲染页面，如果没安装GCF，则使用最高版本的IE内核进行渲染。
    Google Chrome Frame（谷歌内嵌浏览器框架GCF）。
    可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，
而且支持IE6、7、8等多个版本的IE浏览器。
2、css3:border-raduis,opacity
2、js:获取样式，e,e.target,Indexof(),trim(),
2、html:placeholder  jquery.placeholder.js
3、终结者->>好像这个js获取不到的样子
<!–[if lt IE 9]>
  <script src=”http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js”></script>
  <![endif]–>
//---------------Indexof()-------------
  if (!Array.prototype.indexOf)
  {
    Array.prototype.indexOf = function(elt /*, from*/)
    {
      var len = this.length >>> 0;

      var from = Number(arguments[1]) || 0;
      from = (from < 0)
           ? Math.ceil(from)
           : Math.floor(from);
      if (from < 0)
        from += len;

      for (; from < len; from++)
      {
        if (from in this &&
            this[from] === elt)
          return from;
      }
      return -1;
    };
  }
//----------------trim()--------------
  String.prototype.trim=function(){
      return this.replace(/(^\s*)|(\s*$)/g, "");
  }

//默认新窗口打开链接
<base target="_blank" />



------------兼容性----------
火狐里面： button嵌套input[file]不能上传文件，改成a>input